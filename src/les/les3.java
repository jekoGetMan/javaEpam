package les;

import java.util.Scanner;

public class les3 {

    // str.equals("stop") - с объектами
    // с примитивами использвать ==;
    // *********************************************Память
    // LiFO - last int first out - последнюю положили помытой, первой взяли
    // FiFo - очередь
    // Коллекции (queue)
    // Permge - метаданные
    // Статики находятся в обычном
    // young generation / old generation
    // Permgeneration - метаданные - классы и т.д.
    // young generation - там вещи, которые выжили поcле garbage collector
    // Кэш - натив мемори.
    // native memory - cache(многопоточность!) Когда комп вкл. сразу вклю нативпамять
    // строки(урок 5/6)
    // GC - garbage collector (принцип работы, 4 принципа)
    // Понимать как устроена память.
    // Декомпеляция
    // Если вы зашли в офис, то нужно с него выйти, так и с методом. В любом методе используется return
    // javac Main.java
    // javap - c Main.class - декомпиляция класса мейн, где содержится байт код
    // 0 корректно -1 - прервалось 1 - ошибка
    // Терминал
    // значок рекурсии
    // рекурсия всегда должна проверяться
    // метод - перегрузка(одинаковое типы, но разное количество параметров)
    // явный кастинг
    // Вызов сначала смотрит на количство параметров, потом на тип данных.
    // В зависимости от параметры мы понимаем какой из методов нам нужно вызывать
    // overload/overrite/override
    // сигнатура метода (имя метода и параметры)
    // java - статический язык прог. поэтому нужно всегда определять тип
    // javascript - динамический язык, поэтому в массив можно запихивать данные любого типа, а в джаве строго по типу
    // многомерные массивы записываются просто добавлением квадратных скобок вначале
    // float, double = 0.0
    // char = nul (с одной буквой l)
    // boolean = false(default)
    // arr3 = null - потому, что мы никуда не ссылаемся, поэтому null
    // Можно заполнить массив циклом foreach
    // length - памертр, без круглых скоробок, length также применяется к строкам
    // класс Math
    // Math.random - возвращает double по-умолчанию(0.0 - 0.99) arr[3] = (int)(Math.random());
    // Заполнение должно быть в методе
    // Создаем метод fillArray, который принимает массив и он возвращает уже заполненный массив, нужно создать метод, который будет выводить знач. на экран
    // CTRL + ALT + M - быстрое создание метода
    // (0.0 .. 0.9) * 20 - 10 (+ 10 - 10) диапазон значений от 10 до -10
    // math.random
    // Заполнить массив значениями с клавиатуры
    // arr.fori
    // итератор вместо цикла for . for (int i : arr) { System.out.println(i); }
    // Написать матрицу
    // Парадигма ООП (4 принципа)
    // Как говорится - по такому и порядку делается
    // Инкапсуляция - сокрытие данных из вне
    // private int p = 10 - яркий пример инкапсуляции, можем достучаться через геттеры и сеттеры Пароль - инкапс. Он скрывает все содержимое. Рефлексия - разбить телефон.
    // Чужой телефон. Инкапс. - сейф. Метод доступа - пароль.
    // Зачем нужно инкапс? Скрыть что-то. Чтобы кто-то не мог напрямую изменять значения.
    // Ты думаешь, что ты работаешь с одним значением, а кто-то изменил и все поломал. Инкапс. улучшает этот процесс
    // static. Когда объявляем со статиком, то видно на уровне класса. НБУ пример Через имя класса можно обратится к значением без создания объекта.(статик)
    // static (через имя класса обращаемся к данным), не нужно создавать объект.
    // полноценная константа static + final (static final)
    // static через конструктор
    // В полях класса ничего не пишут, как правило
    // констр. спец. метод, который позволяет создать объект.
    // jvm-ка генерирует конструктор без параметров.
    // код конвеншин
    // конструкторы для того, чтобы там происходила инициализация каких-то значений.
    // Разбивать программу. Точка входа: создание объекта и все
    // Всегда нужно создавать поля на уровне private
    // Поля - Конструктор - методы(геттеры и сеттеры)
    // Имена параметров в конструкторе и полей(выше, до конструктора) лучше пускай совпадают.
    // this - ссылка на текущий объект.
    // Параметры model из конструктора, который мы передаем - справа, а куда записываем - слева(this.model = model) Именно этому объекту присвоим модель, цвет.
    // Если мы создаем хотябы один параметр, jvm не создаем констр. по умолч.
    // POJO класс plain old java object. Обычная структура = класс/поля/ констр./ в одном классе. А логика в другом.
    // КОнструктора нету void/int, но есть return
    // 1, 2 ,3 уроки. Наследование и полиморфизм.
    /*
    public static void main(String[] args) {


        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();

        while (true) {
            if (str.equals("stop")) {
                System.out.println("stop");
                break;
            } else {
                System.out.println("error");
                break;
            }
        }
        */

    /*
    static int[] fillArray (int[] arr, int increment) {
        for (int i = 0; i < arr.length; i++) {
            arr[i] = arr[i] * increment;
        }
        return arr;
    }


    public static void main(String[] args) {
        int[] arr = (int)(Math.random() * 10);
        arr = fillArray(arr, 10);
        int i = 0;
        while (i < arr.length) {
            System.out.println(arr[i] + ", ");
            i++;
        }
    */

        /*
        public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
//      int[] arr = new int[5];

        while(true)
        {
            if (num >= 0) {
                System.out.println("good");
                break;
            }
            else if (num < 0)
            {
                System.out.println("bad");
                break;
            }
        }
    }

        */


    }


